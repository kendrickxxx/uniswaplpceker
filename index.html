<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
  const { ethers } = window;

  // RPC (boleh ganti kalau mau node sendiri)
  const RPC = {
    ethereum: "https://rpc.ankr.com/eth",
    arbitrum: "https://arb1.arbitrum.io/rpc",
    optimism: "https://mainnet.optimism.io",
    polygon:  "https://polygon-rpc.com",
    base:     "https://developer-access-mainnet.base.org",
  };

  // NFPM v3
  const NFPM_V3 = {
    ethereum: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88",
    arbitrum: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88",
    optimism: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88",
    polygon:  "0xC36442b4a4522E871399CD717aBDD847Ab11FE88",
    base:     "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1", // NFPM di Base
  };

  // Uniswap V3 factory (buat cari pool posisi & pool token/USDC)
  const V3_FACTORY = {
    ethereum: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
    base:     "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
    // isi chain lain dari docs Uniswap kalau mau full
  };

  // USDC per chain (buat harga ke USD)
  const USDC = {
    ethereum: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    base:     "0x833589fCD6eD6e08f4c7C32d4f71B54bDa02913",
  };

  const ERC20_ABI = [
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
  ];

  const ABI_V3 = [
    "function positions(uint256 tokenId) view returns (" +
    "uint96,address,address,address,uint24,int24,int24,uint128," +
    "uint256,uint256,uint128,uint128)"
  ];

  const V3_FACTORY_ABI = [
    "function getPool(address tokenA, address tokenB, uint24 fee) view returns (address)"
  ];

  const V3_POOL_ABI = [
    "function slot0() view returns (uint160 sqrtPriceX96,int24 tick,uint16,uint16,uint16,uint8,bool)",
    "function token0() view returns (address)",
    "function token1() view returns (address)"
  ];

  // V4
  const POSM_V4 = {
    ethereum: "0x000000000022D473030F116dDEE9F6B43aC78A5A",
    arbitrum: "0x000000000022D473030F116dDEE9F6B43aC78A5A",
    optimism: "0x000000000022D473030F116dDEE9F6B43aC78A5A",
    polygon:  "0x000000000022D473030F116dDEE9F6B43aC78A5A",
    base:     "0x000000000022D473030F116dDEE9F6B43aC78A5A",
  };

  const ABI_V4 = [
    "function getPositionLiquidity(uint256 tokenId) view returns (uint128)",
    "function getPoolAndPositionInfo(uint256 tokenId) view returns (" +
      "tuple(address currency0,address currency1,uint24 fee,int24 tickSpacing,address hooks) poolKey," +
      "uint256 positionInfo)"
  ];

  const chainLabels = {
    ethereum: "Ethereum",
    arbitrum: "Arbitrum",
    optimism: "Optimism",
    polygon:  "Polygon",
    base:     "Base",
  };

  const resultBox   = document.getElementById("resultBox");
  const resultJson  = document.getElementById("resultJson");
  const quickSummary = document.getElementById("quickSummary");
  const usdSummary  = document.getElementById("usdSummary");
  const statusTags  = document.getElementById("statusTags");

  function setStatusTags({ hasLiquidity, hasRewards, version }) {
    statusTags.innerHTML = "";
    const tag = (text, cls) => {
      const el = document.createElement("span");
      el.className = "tag " + cls;
      el.textContent = text;
      statusTags.appendChild(el);
    };
    tag(version.toUpperCase(), "neutral");
    if (hasLiquidity === true) tag("HAS LIQUIDITY", "ok");
    if (hasLiquidity === false) tag("NO LIQUIDITY", "bad");
    if (version === "v3") {
      if (hasRewards === true) tag("HAS REWARD", "ok");
      if (hasRewards === false) tag("NO REWARD SEEN", "neutral");
    } else {
      tag("REWARD VIA SDK/SUBGRAPH", "neutral");
    }
  }

  const nfUSD = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    maximumFractionDigits: 2,
  });

  async function getTokenMeta(provider, address) {
    const c = new ethers.Contract(address, ERC20_ABI, provider);
    const [dec, sym] = await Promise.all([c.decimals(), c.symbol()]);
    return { decimals: dec, symbol: sym };
  }

  // harga token → USD via pool token/USDC
  async function getTokenPriceUsdFromPool(provider, chain, token) {
    const usdcAddr = USDC[chain];
    const factoryAddr = V3_FACTORY[chain];
    if (!usdcAddr || !factoryAddr) return null;

    if (token.toLowerCase() === usdcAddr.toLowerCase()) return 1;

    const factory = new ethers.Contract(factoryAddr, V3_FACTORY_ABI, provider);

    const feeTiers = [500, 3000]; // 0.05% lalu 0.3%
    let poolAddr = ethers.constants.AddressZero;

    for (const fee of feeTiers) {
      const p = await factory.getPool(token, usdcAddr, fee);
      if (p !== ethers.constants.AddressZero) {
        poolAddr = p;
        break;
      }
    }
    if (poolAddr === ethers.constants.AddressZero) return null;

    const pool = new ethers.Contract(poolAddr, V3_POOL_ABI, provider);
    const [slot0, poolToken0, poolToken1, metaToken, metaUSDC] = await Promise.all([
      pool.slot0(),
      pool.token0(),
      pool.token1(),
      getTokenMeta(provider, token),
      getTokenMeta(provider, usdcAddr),
    ]);

    const sqrtPriceX96 = slot0[0];
    const priceX96Squared = sqrtPriceX96.mul(sqrtPriceX96);
    const Q192 = ethers.BigNumber.from(2).pow(192);

    let price;
    if (token.toLowerCase() === poolToken0.toLowerCase()) {
      // token0 vs USDC
      const ratio = priceX96Squared
        .mul(ethers.BigNumber.from(10).pow(metaToken.decimals))
        .div(Q192.mul(ethers.BigNumber.from(10).pow(metaUSDC.decimals)));
      price = parseFloat(ratio.toString());
    } else if (token.toLowerCase() === poolToken1.toLowerCase()) {
      // token1 vs token0(=USDC) → kebalik
      const ratio = priceX96Squared
        .mul(ethers.BigNumber.from(10).pow(metaUSDC.decimals))
        .div(Q192.mul(ethers.BigNumber.from(10).pow(metaToken.decimals)));
      const raw = parseFloat(ratio.toString());
      if (raw === 0) return null;
      price = 1 / raw;
    } else {
      return null;
    }

    return price;
  }

  // konversi liquidity → amount0 & amount1 (float, human units)
  function liquidityToAmounts(liqBN, tickLower, tickUpper, currentTick, dec0, dec1) {
    const L = parseFloat(liqBN.toString());
    if (L === 0) return { amount0: 0, amount1: 0 };

    const sa = Math.pow(1.0001, tickLower / 2);
    const sb = Math.pow(1.0001, tickUpper / 2);
    const sc = Math.pow(1.0001, currentTick / 2);

    let amount0, amount1;

    if (currentTick <= tickLower) {
      // all token0
      amount0 = L * (sb - sa) / (sa * sb);
      amount1 = 0;
    } else if (currentTick >= tickUpper) {
      // all token1
      amount0 = 0;
      amount1 = L * (sb - sa);
    } else {
      // mixture
      amount0 = L * (sb - sc) / (sc * sb);
      amount1 = L * (sc - sa);
    }

    // human readable (div decimals)
    const human0 = amount0 / Math.pow(10, dec0);
    const human1 = amount1 / Math.pow(10, dec1);

    return { amount0: human0, amount1: human1 };
  }

  document.getElementById("checkBtn").addEventListener("click", async () => {
    const chain   = document.getElementById("chain").value;
    const version = document.getElementById("version").value;
    const tokenId = document.getElementById("tokenId").value.trim();

    if (!tokenId) {
      alert("Masukkan NFT tokenId dulu.");
      return;
    }

    const rpcUrl = RPC[chain];
    resultBox.style.display = "block";
    quickSummary.textContent = "Query on-chain…";
    usdSummary.textContent = "";
    resultJson.textContent = "// fetching…";

    try {
      const provider = new ethers.providers.JsonRpcProvider(rpcUrl);

      // =================== V3 ===================
      if (version === "v3") {
        const nfpmAddr = NFPM_V3[chain];
        const nfpm = new ethers.Contract(nfpmAddr, ABI_V3, provider);
        const pos = await nfpm.positions(tokenId);

        const token0 = pos[2];
        const token1 = pos[3];
        const feeTier = pos[4];
        const tickLower = pos[5];
        const tickUpper = pos[6];
        const liquidity = pos[7];
        const tokensOwed0 = pos[10];
        const tokensOwed1 = pos[11];

        const hasLiquidity = liquidity.gt(0);
        const hasRewards = tokensOwed0.gt(0) || tokensOwed1.gt(0);

        const data = {
          version: "v3",
          chain: chainLabels[chain] || chain,
          tokenId,
          token0,
          token1,
          feeTier: feeTier.toString(),
          tickLower: tickLower.toString(),
          tickUpper: tickUpper.toString(),
          liquidity: liquidity.toString(),
          hasLiquidity,
          tokensOwed0: tokensOwed0.toString(),
          tokensOwed1: tokensOwed1.toString(),
          hasUnclaimedRewards: hasRewards,
        };

        setStatusTags({ hasLiquidity, hasRewards, version });

        quickSummary.textContent = hasLiquidity
          ? `Posisi V3 di ${data.chain} masih aktif (liquidity > 0).`
          : `Posisi V3 di ${data.chain} tampaknya tidak punya liquidity (liquidity = 0).`;

        // ===== meta token & harga on-chain =====
        let usdLine = "Estimasi USD reward/liquidity tidak tersedia (factory/USDC/pool belum di-set atau nggak ketemu).";

        try {
          const [meta0, meta1] = await Promise.all([
            getTokenMeta(provider, token0),
            getTokenMeta(provider, token1),
          ]);

          const amtReward0 = parseFloat(ethers.utils.formatUnits(tokensOwed0, meta0.decimals));
          const amtReward1 = parseFloat(ethers.utils.formatUnits(tokensOwed1, meta1.decimals));

          // harga per token (USD)
          let [price0, price1] = [null, null];
          if (V3_FACTORY[chain] && USDC[chain]) {
            // harga bisa kepakai untuk reward & liquidity
            [price0, price1] = await Promise.all([
              getTokenPriceUsdFromPool(provider, chain, token0),
              getTokenPriceUsdFromPool(provider, chain, token1),
            ]);
          }

          let rewardUsd0 = 0, rewardUsd1 = 0, liqUsd0 = 0, liqUsd1 = 0;

          if (amtReward0 > 0 && price0 != null) rewardUsd0 = amtReward0 * price0;
          if (amtReward1 > 0 && price1 != null) rewardUsd1 = amtReward1 * price1;

          let totalRewardUsd = rewardUsd0 + rewardUsd1;

          // === liquidity → amount token → USD ===
          let totalLiqUsd = 0;
          if (hasLiquidity && price0 != null && price1 != null && V3_FACTORY[chain]) {
            const factory = new ethers.Contract(V3_FACTORY[chain], V3_FACTORY_ABI, provider);
            const poolAddr = await factory.getPool(token0, token1, feeTier);
            if (poolAddr !== ethers.constants.AddressZero) {
              const pool = new ethers.Contract(poolAddr, V3_POOL_ABI, provider);
              const slot0 = await pool.slot0();
              const currentTick = slot0[1]; // int24

              const { amount0, amount1 } = liquidityToAmounts(
                liquidity,
                tickLower,
                tickUpper,
                currentTick,
                meta0.decimals,
                meta1.decimals
              );

              liqUsd0 = amount0 * (price0 || 0);
              liqUsd1 = amount1 * (price1 || 0);
              totalLiqUsd = liqUsd0 + liqUsd1;

              data.estimatedAmount0 = amount0;
              data.estimatedAmount1 = amount1;
            }
          }

          if (totalRewardUsd > 0 || totalLiqUsd > 0) {
            const parts = [];
            if (totalRewardUsd > 0) {
              parts.push(`reward ≈ ${nfUSD.format(totalRewardUsd)}`);
            }
            if (totalLiqUsd > 0) {
              parts.push(`liquidity ≈ ${nfUSD.format(totalLiqUsd)}`);
            }
            const totalAll = totalRewardUsd + totalLiqUsd;
            usdLine =
              `Estimasi on-chain (token/USDC): ` +
              parts.join(" + ") +
              (totalAll > 0 ? ` → total ≈ ${nfUSD.format(totalAll)}.` : ".");
          }

        } catch (e) {
          console.warn("Gagal hitung USD:", e);
        }

        usdSummary.textContent = usdLine;
        resultJson.textContent = JSON.stringify(data, null, 2);
        return;
      }

      // =================== V4 ===================
      if (version === "v4") {
        const posmAddr = POSM_V4[chain];
        const posm = new ethers.Contract(posmAddr, ABI_V4, provider);
        const liquidity = await posm.getPositionLiquidity(tokenId);
        const poolInfo = await posm.getPoolAndPositionInfo(tokenId);
        const poolKey  = poolInfo[0];

        const hasLiquidity = liquidity.gt(0);

        const data = {
          version: "v4",
          chain: chainLabels[chain] || chain,
          tokenId,
          liquidity: liquidity.toString(),
          hasLiquidity,
          pool: {
            token0: poolKey.currency0,
            token1: poolKey.currency1,
            fee: poolKey.fee,
            tickSpacing: poolKey.tickSpacing,
            hooks: poolKey.hooks,
          },
          note: "V4 belum punya tokensOwed view; reward perlu SDK/subgraph.",
        };

        setStatusTags({ hasLiquidity, hasRewards: null, version });

        quickSummary.textContent = hasLiquidity
          ? `Posisi V4 di ${data.chain} masih punya liquidity.`
          : `Posisi V4 di ${data.chain} kemungkinan sudah tidak aktif (liquidity = 0).`;

        usdSummary.textContent = "Estimasi USD untuk V4 tidak dihitung di versi ini (butuh SDK/subgraph).";
        resultJson.textContent = JSON.stringify(data, null, 2);
        return;
      }

    } catch (err) {
      setStatusTags({ hasLiquidity: null, hasRewards: null, version: document.getElementById("version").value });
      quickSummary.textContent = "Terjadi error saat query on-chain.";
      usdSummary.textContent = "";
      resultJson.textContent = "Error: " + (err.reason || err.message || String(err));
    }
  });
</script>
